---
phase: 02-quiz-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - medtriad/types/quiz-state.ts
  - medtriad/hooks/use-quiz-reducer.ts
  - medtriad/hooks/use-countdown-timer.ts
autonomous: true

must_haves:
  truths:
    - "Quiz state can transition between idle, playing, answered, and completed"
    - "Timer decrements every second when quiz is playing"
    - "Selecting an answer updates score and combo in state"
    - "State resets cleanly for new quiz rounds"
  artifacts:
    - path: "medtriad/types/quiz-state.ts"
      provides: "QuizStatus, QuizState, QuizAction type definitions"
      exports: ["QuizStatus", "QuizState", "QuizAction"]
    - path: "medtriad/hooks/use-quiz-reducer.ts"
      provides: "Quiz state machine with reducer pattern"
      exports: ["useQuizReducer"]
    - path: "medtriad/hooks/use-countdown-timer.ts"
      provides: "Timer hook with cleanup"
      exports: ["useCountdownTimer"]
  key_links:
    - from: "medtriad/hooks/use-quiz-reducer.ts"
      to: "medtriad/types/quiz-state.ts"
      via: "imports QuizState, QuizAction"
      pattern: "import.*from.*quiz-state"
    - from: "medtriad/hooks/use-quiz-reducer.ts"
      to: "@/types"
      via: "imports QuizQuestion"
      pattern: "import.*QuizQuestion.*from.*@/types"
---

<objective>
Create quiz state management foundation with reducer pattern and timer hook.

Purpose: Establish the state machine and timer logic that will power the quiz gameplay, following patterns from the research document (useReducer as state machine, proper timer cleanup).

Output: Three files - quiz state types, quiz reducer hook, countdown timer hook - that the quiz screen will use to manage gameplay.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quiz-core/02-RESEARCH.md

# Phase 1 delivered types we need
@medtriad/types/question.ts
@medtriad/types/triad.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quiz state types</name>
  <files>medtriad/types/quiz-state.ts</files>
  <action>
Create quiz state type definitions following the research patterns:

1. QuizStatus union type: 'idle' | 'playing' | 'answered' | 'completed'

2. QuizState interface with:
   - status: QuizStatus
   - questions: QuizQuestion[] (import from @/types)
   - currentIndex: number
   - score: number
   - combo: number
   - timeRemaining: number
   - selectedOptionId: string | null

3. QuizAction discriminated union:
   - { type: 'START_QUIZ'; questions: QuizQuestion[] }
   - { type: 'SELECT_ANSWER'; optionId: string; isCorrect: boolean }
   - { type: 'TICK_TIMER' }
   - { type: 'NEXT_QUESTION' }
   - { type: 'RESET' }

4. Export QUESTION_TIME constant (12 seconds) and QUESTION_COUNT constant (10)

Use JSDoc comments on all exported types following the pattern in types/question.ts.
  </action>
  <verify>npx tsc --noEmit in medtriad directory shows no type errors</verify>
  <done>Quiz state types exist and compile cleanly with strict TypeScript</done>
</task>

<task type="auto">
  <name>Task 2: Create useQuizReducer hook</name>
  <files>medtriad/hooks/use-quiz-reducer.ts</files>
  <action>
Create the quiz state machine hook:

1. Create hooks/ directory if it doesn't exist

2. Define initialState constant:
   - status: 'idle'
   - questions: []
   - currentIndex: 0
   - score: 0
   - combo: 1
   - timeRemaining: QUESTION_TIME
   - selectedOptionId: null

3. Implement quizReducer function handling:
   - START_QUIZ: Set status to 'playing', load questions, reset all counters
   - SELECT_ANSWER:
     - Only if status is 'playing'
     - Set status to 'answered'
     - Store selectedOptionId
     - If correct: add 100 * combo to score, increment combo
     - If incorrect: reset combo to 1
   - TICK_TIMER:
     - Only if status is 'playing'
     - Decrement timeRemaining
     - If reaches 0: set status to 'answered', reset combo (timeout = incorrect)
   - NEXT_QUESTION:
     - Increment currentIndex
     - If next index >= questions.length: set status to 'completed'
     - Else: set status to 'playing', reset timeRemaining, clear selectedOptionId
   - RESET: Return initialState

4. Export useQuizReducer hook that returns useReducer(quizReducer, initialState)

Import QUESTION_TIME from @/types/quiz-state. Use stable dispatch reference pattern (dispatch is already stable from useReducer).
  </action>
  <verify>npx tsc --noEmit shows no type errors</verify>
  <done>useQuizReducer hook exports and handles all quiz state transitions correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create useCountdownTimer hook</name>
  <files>medtriad/hooks/use-countdown-timer.ts</files>
  <action>
Create countdown timer hook with proper cleanup:

1. useCountdownTimer(isRunning: boolean, onTick: () => void): void

2. Implementation:
   - Use useRef to store interval ID (ReturnType<typeof setInterval> | null)
   - useEffect that:
     - When isRunning becomes true: start setInterval calling onTick every 1000ms
     - When isRunning becomes false: clear interval
     - Cleanup function always clears interval (prevents unmount leaks)
   - Dependency array: [isRunning, onTick]

3. IMPORTANT: The hook should NOT manage time state itself - it just calls onTick. The quiz reducer handles decrementing time via TICK_TIMER action.

4. Add JSDoc comment explaining the hook's purpose and that onTick should be wrapped in useCallback by the caller.

Follow the research pattern exactly - this is a simple hook that just manages the interval lifecycle.
  </action>
  <verify>npx tsc --noEmit shows no type errors</verify>
  <done>useCountdownTimer hook exports and properly cleans up intervals</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Type check: `cd medtriad && npx tsc --noEmit` passes
2. Files exist:
   - medtriad/types/quiz-state.ts
   - medtriad/hooks/use-quiz-reducer.ts
   - medtriad/hooks/use-countdown-timer.ts
3. Exports work: Each file exports the expected functions/types
</verification>

<success_criteria>
- Quiz state types define complete state machine (idle -> playing -> answered -> completed)
- useQuizReducer handles all action types with correct state transitions
- useCountdownTimer starts/stops interval based on isRunning flag
- All files compile with strict TypeScript
- No runtime dependencies added (uses only React built-ins)
</success_criteria>

<output>
After completion, create `.planning/phases/02-quiz-core/02-01-SUMMARY.md`
</output>
