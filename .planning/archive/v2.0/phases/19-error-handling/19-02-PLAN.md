---
phase: 19-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - medtriad/components/progress/TierProgressBar.tsx
  - medtriad/app/quiz/index.tsx
  - medtriad/services/dev-tools.ts
  - medtriad/app/(tabs)/progress.tsx
autonomous: true

must_haves:
  truths:
    - "Progress bar never overflows beyond 100%"
    - "Quiz result recording never crashes the app"
    - "Dev tools clear data never crashes"
    - "gamesToNext calculation never produces NaN"
  artifacts:
    - path: "medtriad/components/progress/TierProgressBar.tsx"
      provides: "Clamped progress bar that handles out-of-range values"
      contains: "clamp"
    - path: "medtriad/app/quiz/index.tsx"
      provides: "Quiz with try/catch around recordQuizResult"
      contains: "try"
    - path: "medtriad/services/dev-tools.ts"
      provides: "Dev tools with try/catch on clearAllData"
      contains: "try"
    - path: "medtriad/app/(tabs)/progress.tsx"
      provides: "Progress screen with validated gamesToNext"
      contains: "Math.max"
  key_links:
    - from: "medtriad/components/progress/TierProgressBar.tsx"
      to: "medtriad/services/validation.ts"
      via: "import clampProgress"
      pattern: "import.*clampProgress.*from"
---

<objective>
Apply defensive patterns to existing code

Purpose: Harden existing components against edge cases identified in research - progress overflow, async errors, and NaN values
Output: All identified gaps from research closed with defensive patterns
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-error-handling/19-RESEARCH.md
@.planning/phases/19-error-handling/19-01-SUMMARY.md

@medtriad/components/progress/TierProgressBar.tsx
@medtriad/app/quiz/index.tsx
@medtriad/services/dev-tools.ts
@medtriad/app/(tabs)/progress.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Clamp TierProgressBar progress</name>
  <files>medtriad/components/progress/TierProgressBar.tsx</files>
  <action>
Add progress clamping to prevent animation overflow:

1. Add import: `import { clampProgress } from '@/services/validation';`

2. Clamp the progress value in the useEffect:
```typescript
useEffect(() => {
  const safeProgress = clampProgress(progress);
  animatedProgress.value = withTiming(safeProgress, {
    duration: 600,
    easing: Easing.out(Easing.cubic),
  });
}, [progress]);
```

This ensures:
- Values > 1 become 1 (no overflow past 100%)
- Values < 0 become 0 (no negative width)
- NaN becomes 0 (safe fallback)
  </action>
  <verify>
TypeScript compiles: `cd medtriad && npx tsc --noEmit`
Progress bar renders correctly on Progress tab.
  </verify>
  <done>TierProgressBar clamps progress to 0-1 range</done>
</task>

<task type="auto">
  <name>Task 2: Add try/catch to quiz recordQuizResult</name>
  <files>medtriad/app/quiz/index.tsx</files>
  <action>
Wrap the async quiz completion logic in try/catch to prevent crash on storage failure:

In the auto-advance useEffect (around line 88-126), wrap the async operations:

```typescript
const timeout = setTimeout(async () => {
  if (currentIndex >= questions.length - 1) {
    try {
      // Check for new high score BEFORE saving stats
      const isNewHighScore = await checkHighScore(score);

      // Check for tier-up BEFORE recording quiz result
      const { willTierUp, newTier } = checkTierUp(stats?.gamesPlayed ?? 0);

      // Save stats (this increments gamesPlayed and sets pendingTierUp)
      await recordQuizResult(
        correctCountRef.current,
        QUESTION_COUNT,
        maxComboRef.current,
        score
      );

      // Navigate to results with tier-up info
      const perfect = isPerfectRound(correctCountRef.current, QUESTION_COUNT);
      router.replace({
        pathname: '/quiz/results',
        params: {
          score: score.toString(),
          correctCount: correctCountRef.current.toString(),
          bestStreak: maxComboRef.current.toString(),
          isNewHighScore: isNewHighScore ? 'true' : 'false',
          isPerfect: perfect ? 'true' : 'false',
          tierUp: willTierUp ? 'true' : 'false',
          newTierName: newTier?.name ?? '',
          newTierNumber: newTier?.tier.toString() ?? '',
        },
      });
    } catch (error) {
      // DESIGN DECISION (ERR-04): Silent fallback is intentional for MVP.
      // Per 19-RESEARCH.md, user-friendly error messages are not needed here because:
      // 1. The quiz experience completes successfully (user sees results)
      // 2. Only persistence fails, which is invisible to user anyway
      // 3. Showing an error would confuse users ("save failed" when they see their score)
      // We log for debugging but don't interrupt the user flow.
      console.error('Failed to save quiz result:', error);

      // Still navigate to results even if save failed
      // User sees their score, just may not persist
      router.replace({
        pathname: '/quiz/results',
        params: {
          score: score.toString(),
          correctCount: correctCountRef.current.toString(),
          bestStreak: maxComboRef.current.toString(),
          isNewHighScore: 'false',
          isPerfect: isPerfectRound(correctCountRef.current, QUESTION_COUNT) ? 'true' : 'false',
          tierUp: 'false',
          newTierName: '',
          newTierNumber: '',
        },
      });
    }
  } else {
    dispatch({ type: 'NEXT_QUESTION' });
  }
}, ANSWER_DELAY);
```

Key: Even on error, navigate to results so user sees their score. Just mark isNewHighScore/tierUp as false.
  </action>
  <verify>
TypeScript compiles: `cd medtriad && npx tsc --noEmit`
Quiz completes and navigates to results screen.
  </verify>
  <done>Quiz completion wrapped in try/catch with fallback navigation and documented design decision</done>
</task>

<task type="auto">
  <name>Task 3: Add try/catch to dev-tools clearAllData and validate gamesToNext</name>
  <files>medtriad/services/dev-tools.ts, medtriad/app/(tabs)/progress.tsx</files>
  <action>
**dev-tools.ts:**
Wrap clearAllData in try/catch:

```typescript
export async function clearAllData(): Promise<void> {
  try {
    await AsyncStorage.multiRemove(ALL_APP_KEYS);
  } catch (error) {
    console.error('Failed to clear all data:', error);
    // Rethrow to let caller handle (UI shows error state)
    throw error;
  }
}
```

**progress.tsx:**
Add explicit validation to gamesToNext calculation (line ~51):

```typescript
// Games needed to reach next tier (only show if not at max tier)
// Use Math.max to ensure never negative, fallback to 0 if calculation fails
const gamesToNext = nextTier
  ? Math.max(0, (nextTier.gamesRequired ?? nextTier.pointsRequired ?? 0) - (stats?.gamesPlayed ?? 0))
  : 0;
```

This ensures:
- If nextTier properties are undefined, fallback to 0
- If stats.gamesPlayed is undefined, fallback to 0
- Result is never negative (Math.max)
  </action>
  <verify>
TypeScript compiles: `cd medtriad && npx tsc --noEmit`
Progress screen displays correctly with tier progress.
Dev tools still work in debug mode.
  </verify>
  <done>Dev tools has try/catch, progress screen validates gamesToNext</done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds: `cd medtriad && npx tsc --noEmit`
2. App launches without errors
3. Progress screen shows tier progress without NaN
4. Quiz completion navigates to results
5. TierProgressBar never shows overflow
</verification>

<success_criteria>
- TierProgressBar.tsx imports and uses clampProgress
- quiz/index.tsx has try/catch around recordQuizResult with fallback navigation
- dev-tools.ts has try/catch on clearAllData
- progress.tsx uses Math.max and nullish coalescing for gamesToNext
- TypeScript compiles without errors
- App functions correctly in all tested scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-handling/19-02-SUMMARY.md`
</output>
