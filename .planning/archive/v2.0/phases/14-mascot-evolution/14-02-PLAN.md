---
phase: 14-mascot-evolution
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - medtriad/services/stats-storage.ts
  - medtriad/hooks/useStats.ts
  - medtriad/app/quiz/index.tsx
  - medtriad/components/results/TierUpCelebration.tsx
  - medtriad/app/quiz/results.tsx
autonomous: true

must_haves:
  truths:
    - "Tier-up is detected when completing a game that crosses tier threshold"
    - "Results screen shows celebration animation when tier-up occurs"
    - "Mascot scales out, confetti fires, mascot scales back in with new tier"
    - "pendingTierUp flag persists for catch-up celebration"
  artifacts:
    - path: "medtriad/services/stats-storage.ts"
      provides: "pendingTierUp field in StoredStats"
      contains: "pendingTierUp"
    - path: "medtriad/hooks/useStats.ts"
      provides: "pendingTierUp exposed from hook"
      exports: ["pendingTierUp", "clearPendingTierUp"]
    - path: "medtriad/components/results/TierUpCelebration.tsx"
      provides: "Scale out/in mascot transition with confetti"
      min_lines: 80
    - path: "medtriad/app/quiz/results.tsx"
      provides: "Shows TierUpCelebration when tierUp param is true"
      contains: "TierUpCelebration"
  key_links:
    - from: "medtriad/app/quiz/index.tsx"
      to: "medtriad/app/quiz/results.tsx"
      via: "tierUp route param"
      pattern: "tierUp.*true"
    - from: "medtriad/app/quiz/results.tsx"
      to: "medtriad/components/results/TierUpCelebration.tsx"
      via: "conditional render"
      pattern: "<TierUpCelebration"
---

<objective>
Implement tier-up detection in quiz flow and create celebration animation on Results screen with scale out/in mascot transition and confetti.

Purpose: Users experience a satisfying celebration moment when they reach a new tier
Output: Working tier-up celebration on Results screen with confetti and mascot transition
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-mascot-evolution/14-RESEARCH.md
@.planning/phases/14-mascot-evolution/14-CONTEXT.md
@.planning/phases/14-mascot-evolution/14-01-SUMMARY.md
@medtriad/services/stats-storage.ts
@medtriad/hooks/useStats.ts
@medtriad/app/quiz/index.tsx
@medtriad/app/quiz/results.tsx
@medtriad/constants/theme.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pendingTierUp to storage and useStats hook</name>
  <files>medtriad/services/stats-storage.ts, medtriad/hooks/useStats.ts</files>
  <action>
**In stats-storage.ts:**

1. Update StoredStats interface to include pendingTierUp:

```typescript
export interface StoredStats {
  // ... existing fields ...
  pendingTierUp: { tier: number; name: string } | null;
}
```

2. Update DEFAULT_STATS:

```typescript
const DEFAULT_STATS: StoredStats = {
  // ... existing fields ...
  pendingTierUp: null,
};
```

3. Update updateAfterQuiz to set pendingTierUp when tier-up occurs:

```typescript
import { getTierForGames } from './mastery';

export async function updateAfterQuiz(
  correctCount: number,
  totalQuestions: number,
  maxStreak: number,
  score: number
): Promise<StoredStats> {
  const currentStats = await loadStats();

  // Check for tier-up BEFORE incrementing gamesPlayed
  const tierBefore = getTierForGames(currentStats.gamesPlayed);
  const tierAfter = getTierForGames(currentStats.gamesPlayed + 1);
  const didTierUp = tierAfter.tier > tierBefore.tier;

  const { newStreak } = calculateStreak(
    currentStats.dailyStreak,
    currentStats.lastPlayedDate
  );

  const updatedStats: StoredStats = {
    // ... existing fields ...
    pendingTierUp: didTierUp
      ? { tier: tierAfter.tier, name: tierAfter.name }
      : currentStats.pendingTierUp, // Preserve existing pending if no new tier-up
  };

  await saveStats(updatedStats);
  return updatedStats;
}
```

4. Add clearPendingTierUp function:

```typescript
/**
 * Clear the pending tier-up flag after celebration is shown
 */
export async function clearPendingTierUp(): Promise<void> {
  const stats = await loadStats();
  await saveStats({ ...stats, pendingTierUp: null });
}
```

**In useStats.ts:**

1. Import clearPendingTierUp from stats-storage

2. Add to StatsData interface:
```typescript
export interface StatsData {
  // ... existing fields ...
  pendingTierUp: { tier: number; name: string } | null;
  clearPendingTierUp: () => Promise<void>;
}
```

3. Extract pendingTierUp from stats and expose clearPendingTierUp:
```typescript
const pendingTierUp = stats?.pendingTierUp ?? null;

const handleClearPendingTierUp = useCallback(async () => {
  await clearPendingTierUp();
  await fetchStats(); // Refresh to reflect cleared state
}, [fetchStats]);

return {
  // ... existing ...
  pendingTierUp,
  clearPendingTierUp: handleClearPendingTierUp,
};
```
  </action>
  <verify>TypeScript compiles. pendingTierUp field accessible via useStats hook.</verify>
  <done>pendingTierUp persists in storage and is accessible via useStats. clearPendingTierUp function available to clear the flag.</done>
</task>

<task type="auto">
  <name>Task 2: Detect tier-up in quiz and pass to Results</name>
  <files>medtriad/app/quiz/index.tsx</files>
  <action>
Modify the quiz completion flow to detect tier-up BEFORE calling recordQuizResult:

1. Import checkTierUp from mastery.ts:
```typescript
import { checkTierUp } from '@/services/mastery';
```

2. In the auto-advance useEffect, capture tier-up before saving stats:

```typescript
useEffect(() => {
  if (status !== 'answered') return;

  const timeout = setTimeout(async () => {
    if (currentIndex >= questions.length - 1) {
      // Check for new high score BEFORE saving stats
      const isNewHighScore = await checkHighScore(score);

      // Check for tier-up BEFORE recording quiz result
      // stats?.gamesPlayed is the current count, quiz will increment it
      const { willTierUp, newTier } = checkTierUp(stats?.gamesPlayed ?? 0);

      // Save stats (this increments gamesPlayed and sets pendingTierUp)
      await recordQuizResult(
        correctCountRef.current,
        QUESTION_COUNT,
        maxComboRef.current,
        score
      );

      // Navigate to results with tier-up info
      const perfect = isPerfectRound(correctCountRef.current, QUESTION_COUNT);
      router.replace({
        pathname: '/quiz/results',
        params: {
          score: score.toString(),
          correctCount: correctCountRef.current.toString(),
          bestStreak: maxComboRef.current.toString(),
          isNewHighScore: isNewHighScore ? 'true' : 'false',
          isPerfect: perfect ? 'true' : 'false',
          // New tier-up params
          tierUp: willTierUp ? 'true' : 'false',
          newTierName: newTier?.name ?? '',
          newTierNumber: newTier?.tier.toString() ?? '',
        },
      });
    } else {
      // ... existing next question logic
    }
  }, ANSWER_DELAY);

  return () => clearTimeout(timeout);
}, [status, currentIndex, questions.length, dispatch, router, score, recordQuizResult, checkHighScore, stats?.gamesPlayed]);
```

3. Update ResultsParams type at top of file to match (for documentation, actual parsing in results.tsx):
```typescript
// Note: Results screen parses these params
// tierUp, newTierName, newTierNumber added for tier-up celebration
```
  </action>
  <verify>TypeScript compiles. Quiz navigates to results with tierUp param.</verify>
  <done>Quiz detects tier-up before recording result and passes tierUp, newTierName, newTierNumber params to Results screen.</done>
</task>

<task type="auto">
  <name>Task 3: Create TierUpCelebration component and integrate into Results</name>
  <files>medtriad/components/results/TierUpCelebration.tsx, medtriad/app/quiz/results.tsx</files>
  <action>
**Create TierUpCelebration.tsx:**

```typescript
import { useEffect, useRef, useState } from 'react';
import { StyleSheet, Text, View, useWindowDimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';
import ConfettiCannon from 'react-native-confetti-cannon';
import { TriMascot } from '@/components/home/TriMascot';
import { Colors, Typography, Spacing, Easings, Durations } from '@/constants/theme';

type TierUpCelebrationProps = {
  oldTier: number;
  newTier: number;
  newTierName: string;
  onComplete?: () => void;
};

export function TierUpCelebration({
  oldTier,
  newTier,
  newTierName,
  onComplete,
}: TierUpCelebrationProps) {
  const colors = Colors.light;
  const { width, height } = useWindowDimensions();
  const confettiRef = useRef<ConfettiCannon>(null);

  // Track which tier image to display
  const [displayedTier, setDisplayedTier] = useState(oldTier);
  const [showMessage, setShowMessage] = useState(false);

  // Animation values
  const mascotScale = useSharedValue(1);
  const messageOpacity = useSharedValue(0);

  useEffect(() => {
    // Start the celebration sequence after a brief delay
    const timer = setTimeout(() => {
      // Phase 1: Scale mascot out
      mascotScale.value = withTiming(0, { duration: 300 }, (finished) => {
        if (finished) {
          // Phase 2: Switch to new tier image and fire confetti
          runOnJS(setDisplayedTier)(newTier);
          runOnJS(triggerConfetti)();

          // Phase 3: Scale mascot back in with spring after confetti starts
          setTimeout(() => {
            mascotScale.value = withSpring(1, Easings.bouncy);
            // Show "Level Up!" message
            runOnJS(setShowMessage)(true);
            messageOpacity.value = withSpring(1, Easings.gentle);
          }, 200);
        }
      });
    }, 500); // Initial delay to let results screen settle

    return () => clearTimeout(timer);
  }, []);

  const triggerConfetti = () => {
    confettiRef.current?.start();
    // Call onComplete after celebration finishes
    setTimeout(() => {
      onComplete?.();
    }, 2500);
  };

  const mascotAnimatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: mascotScale.value }],
  }));

  const messageAnimatedStyle = useAnimatedStyle(() => ({
    opacity: messageOpacity.value,
  }));

  return (
    <View style={styles.container}>
      {/* Mascot with scale animation */}
      <Animated.View style={[styles.mascotWrapper, mascotAnimatedStyle]}>
        <TriMascot
          mood="happy"
          size="lg"
          tier={displayedTier}
          context="home"
        />
      </Animated.View>

      {/* Level Up message */}
      {showMessage && (
        <Animated.View style={[styles.messageContainer, messageAnimatedStyle]}>
          <Text style={[styles.levelUpText, { color: colors.primary }]}>
            Level Up!
          </Text>
          <Text style={[styles.tierName, { color: colors.text }]}>
            You're now a {newTierName}
          </Text>
        </Animated.View>
      )}

      {/* Confetti */}
      <ConfettiCannon
        ref={confettiRef}
        count={200}
        origin={{ x: width / 2, y: -10 }}
        fallSpeed={3000}
        fadeOut
        autoStart={false}
        colors={['#3B82F6', '#22C55E', '#FACC15', '#F97316', '#EC4899', '#8B5CF6']}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  mascotWrapper: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  messageContainer: {
    alignItems: 'center',
    marginTop: Spacing.lg,
  },
  levelUpText: {
    ...Typography.display,
    fontSize: 32,
    fontWeight: '700',
  },
  tierName: {
    ...Typography.heading,
    marginTop: Spacing.xs,
  },
});
```

**Update results.tsx:**

1. Add imports:
```typescript
import { TierUpCelebration } from '@/components/results/TierUpCelebration';
```

2. Update ResultsParams type:
```typescript
type ResultsParams = {
  score: string;
  correctCount: string;
  bestStreak: string;
  isNewHighScore: string;
  isPerfect: string;
  tierUp: string;
  newTierName: string;
  newTierNumber: string;
};
```

3. Parse tier-up params:
```typescript
const tierUp = params.tierUp === 'true';
const newTierName = params.newTierName ?? '';
const newTierNumber = parseInt(params.newTierNumber ?? '0', 10);
const oldTierNumber = newTierNumber > 1 ? newTierNumber - 1 : 1;
```

4. Add state to track celebration completion:
```typescript
const [celebrationComplete, setCelebrationComplete] = useState(!tierUp);
```

5. Replace the mascot section with conditional tier-up celebration:

```typescript
{/* Mascot or Tier-Up Celebration */}
<Animated.View
  entering={FadeInUp.delay(0).duration(Durations.normal).springify()}
>
  {tierUp && !celebrationComplete ? (
    <TierUpCelebration
      oldTier={oldTierNumber}
      newTier={newTierNumber}
      newTierName={newTierName}
      onComplete={() => setCelebrationComplete(true)}
    />
  ) : (
    <TriMascot mood={mascotMood} size="md" tier={tier.tier} context="results" />
  )}
</Animated.View>
```

6. When tier-up celebration is showing, also update the result message:
```typescript
const resultMessage = tierUp && !celebrationComplete
  ? '' // TierUpCelebration shows its own message
  : getResultMessage(correctCount, isPerfect);
```

7. Ensure confetti for perfect rounds doesn't conflict with tier-up confetti:
```typescript
// Trigger confetti for perfect rounds (only if not showing tier-up celebration)
useEffect(() => {
  if (isPerfect && !tierUp) {
    const timeout = setTimeout(() => {
      confettiRef.current?.start();
    }, 1200);
    return () => clearTimeout(timeout);
  }
}, [isPerfect, tierUp]);
```
  </action>
  <verify>TypeScript compiles. App runs and shows tier-up celebration when reaching a new tier.</verify>
  <done>TierUpCelebration component displays on Results when tierUp=true with scale out/in transition and confetti burst. "Level Up! You're now a [TierName]" message appears.</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Test tier-up flow manually:
   - Set gamesPlayed to 9 (one away from Intern)
   - Complete a quiz
   - Results screen should show tier-up celebration with confetti
   - Mascot scales out, switches to new tier image, scales back in
   - "Level Up! You're now an Intern" message appears
3. Verify pendingTierUp is set in storage after tier-up
</verification>

<success_criteria>
- pendingTierUp field persists in AsyncStorage
- useStats exposes pendingTierUp and clearPendingTierUp
- Quiz detects tier-up before recording result
- Results screen receives tierUp, newTierName, newTierNumber params
- TierUpCelebration shows scale out/in mascot transition with confetti
- "Level Up! You're now a [TierName]" message appears during celebration
- Perfect round confetti doesn't overlap with tier-up confetti
</success_criteria>

<output>
After completion, create `.planning/phases/14-mascot-evolution/14-02-SUMMARY.md`
</output>
