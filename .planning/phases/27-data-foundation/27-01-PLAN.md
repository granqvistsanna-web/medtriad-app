---
phase: 27-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - medtriad/types/triad-performance.ts
  - medtriad/services/triad-performance-storage.ts
  - medtriad/app/quiz/index.tsx
  - medtriad/app/quiz/study.tsx
  - medtriad/hooks/use-quiz-reducer.ts
  - medtriad/types/quiz-state.ts
autonomous: true

must_haves:
  truths:
    - "After answering a question, user's performance on that specific triad is recorded"
    - "User's historical accuracy per triad persists across app restarts"
    - "Response time for each answer is captured and stored"
    - "Existing user data (streaks, high scores, tier, categoryMastery) remains intact"
  artifacts:
    - path: "medtriad/types/triad-performance.ts"
      provides: "Type definitions for per-triad tracking"
      exports: ["TriadPerformance", "TriadPerformanceRecord"]
    - path: "medtriad/services/triad-performance-storage.ts"
      provides: "AsyncStorage CRUD for triad performance data"
      exports: ["loadTriadPerformance", "recordTriadAnswer", "getTriadPerformance"]
  key_links:
    - from: "medtriad/app/quiz/index.tsx"
      to: "medtriad/services/triad-performance-storage.ts"
      via: "recordTriadAnswer called on each answer"
      pattern: "recordTriadAnswer"
    - from: "medtriad/app/quiz/study.tsx"
      to: "medtriad/services/triad-performance-storage.ts"
      via: "recordTriadAnswer called on each answer"
      pattern: "recordTriadAnswer"
    - from: "medtriad/services/triad-performance-storage.ts"
      to: "AsyncStorage"
      via: "persists triad performance data"
      pattern: "@react-native-async-storage"
---

<objective>
Create per-triad performance tracking system that records individual triad results (correct/incorrect, response time, last seen) whenever a user answers a question in Quiz or Study mode.

Purpose: Foundation data layer that enables adaptive difficulty, spaced repetition, and daily challenges in subsequent phases
Output: Type definitions, storage service, and integrated tracking in quiz flows
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

@medtriad/types/triad.ts
@medtriad/types/quiz-state.ts
@medtriad/services/stats-storage.ts
@medtriad/services/study-storage.ts
@medtriad/app/quiz/index.tsx
@medtriad/app/quiz/study.tsx
@medtriad/hooks/use-quiz-reducer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create triad performance types and storage service</name>
  <files>medtriad/types/triad-performance.ts, medtriad/services/triad-performance-storage.ts</files>
  <action>
Create type definitions and storage service for per-triad performance tracking.

**Types (medtriad/types/triad-performance.ts):**

```typescript
/**
 * Performance data for a single triad
 */
export interface TriadPerformance {
  /** Number of times answered correctly */
  correctCount: number;

  /** Number of times answered incorrectly (including timeouts) */
  incorrectCount: number;

  /** ISO date string of when this triad was last answered */
  lastSeenAt: string;

  /** Average response time in milliseconds (rolling average) */
  avgResponseTimeMs: number;

  /** Number of responses used to calculate avgResponseTimeMs */
  responseCount: number;
}

/**
 * Map of triad ID to performance data
 */
export type TriadPerformanceRecord = Record<string, TriadPerformance>;
```

**Storage service (medtriad/services/triad-performance-storage.ts):**

1. Use storage key `@medtriad_triad_performance`
2. Implement `loadTriadPerformance(): Promise<TriadPerformanceRecord>` - returns empty object if no data
3. Implement `saveTriadPerformance(record: TriadPerformanceRecord): Promise<void>` - saves full record
4. Implement `recordTriadAnswer(triadId: string, isCorrect: boolean, responseTimeMs: number): Promise<void>`:
   - Load existing record
   - If triad not in record, initialize with zeros
   - Increment correctCount or incorrectCount based on isCorrect
   - Update lastSeenAt to current ISO timestamp
   - Update rolling average: newAvg = ((oldAvg * oldCount) + newTime) / (oldCount + 1)
   - Increment responseCount
   - Save updated record
5. Implement `getTriadPerformance(triadId: string): Promise<TriadPerformance | null>` - returns null if triad not tracked yet

Follow existing patterns from stats-storage.ts:
- Use try/catch with console.error for all async operations
- Spread DEFAULT values when loading to handle schema evolution
- Import AsyncStorage from '@react-native-async-storage/async-storage'
  </action>
  <verify>
- TypeScript compiles without errors: `cd medtriad && npx tsc --noEmit`
- Types are properly exported
- Storage functions match existing service patterns (stats-storage.ts)
  </verify>
  <done>
- TriadPerformance and TriadPerformanceRecord types exist and export correctly
- Storage service exports loadTriadPerformance, saveTriadPerformance, recordTriadAnswer, getTriadPerformance
- Rolling average calculation is mathematically correct
  </done>
</task>

<task type="auto">
  <name>Task 2: Track response time in quiz reducer</name>
  <files>medtriad/types/quiz-state.ts, medtriad/hooks/use-quiz-reducer.ts</files>
  <action>
Add response time tracking to the quiz state machine. Response time = questionTime - timeRemaining (in seconds), converted to milliseconds.

**Update types/quiz-state.ts:**

Add to QuizState interface:
```typescript
/** Timestamp when current question started (for response time) */
questionStartedAt: number;

/** Response time for the last answered question in milliseconds */
lastResponseTimeMs: number;
```

Update QuizAction type - SELECT_ANSWER already has timeRemaining, no changes needed.

**Update hooks/use-quiz-reducer.ts:**

1. Add to initialState:
   - `questionStartedAt: 0`
   - `lastResponseTimeMs: 0`

2. In START_QUIZ action:
   - Set `questionStartedAt: Date.now()`

3. In SELECT_ANSWER action:
   - Calculate responseTimeMs = (state.questionTime - action.timeRemaining) * 1000
   - Store in `lastResponseTimeMs`
   - Note: timeRemaining is already passed in the action, so calculation is straightforward

4. In TICK_TIMER when time expires (timeout case):
   - Set `lastResponseTimeMs: state.questionTime * 1000` (full time = slowest possible response)

5. In NEXT_QUESTION action:
   - Reset `questionStartedAt: Date.now()`
   - Keep lastResponseTimeMs (it's historical for the previous question)

This approach is simpler than using questionStartedAt because timeRemaining is already available in the action.
  </action>
  <verify>
- TypeScript compiles without errors: `cd medtriad && npx tsc --noEmit`
- lastResponseTimeMs is available in quiz state after answering
- Timeout scenario records full question time as response time
  </verify>
  <done>
- QuizState includes questionStartedAt and lastResponseTimeMs
- SELECT_ANSWER calculates and stores response time
- TICK_TIMER timeout case stores full question time as response time
- NEXT_QUESTION resets questionStartedAt
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate triad performance tracking into quiz flows</name>
  <files>medtriad/app/quiz/index.tsx, medtriad/app/quiz/study.tsx</files>
  <action>
Integrate triad performance recording into both Quiz Mode and Study Mode.

**Update app/quiz/index.tsx:**

1. Import recordTriadAnswer from '@/services/triad-performance-storage'

2. In handleAnswerSelect function, after dispatch:
   - Get the triad ID: `const triadId = currentQuestion.triad.id`
   - Calculate response time: `const responseTimeMs = (state.questionTime - state.timeRemaining) * 1000`
   - Call recordTriadAnswer(triadId, option.isCorrect, responseTimeMs)
   - Use fire-and-forget pattern (don't await, catch errors silently with console.error)

3. Handle timeout case - in the useEffect that handles status === 'answered':
   - Check if selectedOptionId is null (timeout case)
   - If timeout, record as incorrect with full question time:
     ```typescript
     if (selectedOptionId === null) {
       recordTriadAnswer(
         currentQuestion.triad.id,
         false,
         state.questionTime * 1000
       ).catch(console.error);
     }
     ```
   - Note: The normal answer case is already handled in handleAnswerSelect

**Update app/quiz/study.tsx:**

1. Import recordTriadAnswer from '@/services/triad-performance-storage'

2. In handleAnswerSelect function, after dispatch:
   - Record with responseTimeMs = 0 (study mode is untimed, so response time is not meaningful)
   - Call recordTriadAnswer(currentQuestion.triad.id, option.isCorrect, 0)
   - Use fire-and-forget pattern

Note: Study Mode has no timer, so responseTimeMs = 0 is appropriate. Future phases can decide whether to track actual elapsed time in study mode.

**Error handling pattern (from existing code):**
```typescript
recordTriadAnswer(triadId, isCorrect, responseTimeMs).catch((error) => {
  console.error('Failed to record triad performance:', error);
});
```
  </action>
  <verify>
- App runs without crashes: `cd medtriad && npx expo start`
- Play through a quiz, check AsyncStorage has triad performance data
- Verify data structure in storage matches TriadPerformanceRecord type
- Verify existing stats still work (high score, streak, category mastery)
  </verify>
  <done>
- Quiz Mode records triad performance on each answer (including timeouts)
- Study Mode records triad performance on each answer (with 0 response time)
- Recording failures don't interrupt quiz flow
- Existing functionality (scoring, streaks, tier progression) unchanged
  </done>
</task>

</tasks>

<verification>
1. **DATA-01 (per-triad tracking):** Play a quiz with 2-3 triads. Check AsyncStorage for @medtriad_triad_performance key. Verify correctCount/incorrectCount increments correctly.

2. **DATA-02 (response time):** Answer questions at different speeds. Verify avgResponseTimeMs changes appropriately. Fast answers should have lower times than slow answers.

3. **DATA-03 (backwards compatibility):**
   - Existing @medtriad_stats key should be unchanged
   - Existing @medtriad_tricky_questions key should be unchanged
   - Streaks, high scores, tier progression, category mastery should all still work

4. **Persistence:** Kill and restart app. Verify triad performance data persists.
</verification>

<success_criteria>
- After answering 3 questions on different triads, storage contains performance data for all 3 triads
- Response time varies based on actual time taken to answer
- Timeouts are recorded as incorrect with full question time
- Study mode answers are recorded (with 0 response time)
- Existing app functionality unchanged (regression-free)
</success_criteria>

<output>
After completion, create `.planning/phases/27-data-foundation/27-01-SUMMARY.md`
</output>
