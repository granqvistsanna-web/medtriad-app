---
phase: 04-game-mechanics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - medtriad/services/scoring.ts
  - medtriad/types/quiz-state.ts
  - medtriad/hooks/use-quiz-reducer.ts
  - medtriad/app/quiz/index.tsx
autonomous: true

must_haves:
  truths:
    - "User earns 100 base points for each correct answer"
    - "User earns 0-50 speed bonus based on remaining time (faster = more)"
    - "Combo tier increases from 1x to 2x to 3x every 3 consecutive correct answers"
    - "User earns +500 bonus for perfect 10/10 round"
    - "Timer expiration gives 0 points (no speed bonus)"
  artifacts:
    - path: "medtriad/services/scoring.ts"
      provides: "Pure scoring calculation functions"
      exports: ["calculateSpeedBonus", "getComboTier", "calculateAnswerPoints", "isPerfectRound", "SCORING"]
    - path: "medtriad/types/quiz-state.ts"
      provides: "Extended QuizState and QuizAction types"
      contains: "timeRemaining.*SELECT_ANSWER"
    - path: "medtriad/hooks/use-quiz-reducer.ts"
      provides: "Reducer with scoring calculations"
      contains: "calculateAnswerPoints"
  key_links:
    - from: "medtriad/hooks/use-quiz-reducer.ts"
      to: "medtriad/services/scoring.ts"
      via: "import scoring functions"
      pattern: "import.*from.*scoring"
    - from: "medtriad/app/quiz/index.tsx"
      to: "medtriad/hooks/use-quiz-reducer.ts"
      via: "dispatch SELECT_ANSWER with timeRemaining"
      pattern: "timeRemaining.*state\\.timeRemaining"
---

<objective>
Implement the complete scoring system with base points, speed bonus, combo multiplier tiers, and perfect round bonus.

Purpose: Core game mechanics that reward fast, accurate answers and create satisfying point accumulation.
Output: Working scoring service and updated reducer that calculates points correctly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-game-mechanics/04-RESEARCH.md
@.planning/phases/04-game-mechanics/04-CONTEXT.md

# Existing files to modify
@medtriad/services/question-generator.ts (pattern reference for services)
@medtriad/types/quiz-state.ts
@medtriad/hooks/use-quiz-reducer.ts
@medtriad/app/quiz/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scoring service with pure functions</name>
  <files>medtriad/services/scoring.ts</files>
  <action>
Create a new scoring service with these pure functions:

**Constants:**
```typescript
export const SCORING = {
  BASE_POINTS: 100,
  MAX_SPEED_BONUS: 50,
  PERFECT_ROUND_BONUS: 500,
  COMBO_THRESHOLD: 3,  // Correct answers to increase tier
  MAX_COMBO_TIER: 3,
  TOTAL_TIME: 12,      // Match QUESTION_TIME
} as const;
```

**Functions:**
1. `calculateSpeedBonus(timeRemaining: number, totalTime: number): number`
   - Return 0 if timeRemaining <= 0
   - Use front-loaded quadratic curve: `Math.floor(50 * (timeRemaining/totalTime)^2)`
   - Returns 50 at full time, ~12 at half time, 0 at timeout

2. `getComboTier(consecutiveCorrect: number): number`
   - 0-2 correct: tier 1 (1x)
   - 3-5 correct: tier 2 (2x)
   - 6+: tier 3 (3x max)

3. `calculateAnswerPoints(timeRemaining: number, totalTime: number, comboTier: number): { base, speedBonus, multiplier, total }`
   - Combine base (100) + speed bonus
   - Apply multiplier (comboTier)
   - Return breakdown object

4. `isPerfectRound(correctCount: number, totalQuestions: number): boolean`
   - Return true if all correct

Follow existing service patterns from question-generator.ts.
  </action>
  <verify>
- File exists with all 4 functions and SCORING constants
- `npx tsc --noEmit` passes
  </verify>
  <done>Scoring service created with pure functions for all point calculations</done>
</task>

<task type="auto">
  <name>Task 2: Extend types and update reducer with scoring logic</name>
  <files>medtriad/types/quiz-state.ts, medtriad/hooks/use-quiz-reducer.ts</files>
  <action>
**In quiz-state.ts:**

1. Extend QuizState interface:
   - Change `combo: number` to `consecutiveCorrect: number` (0-based count)
   - Add `lastPointsEarned: number` (for floating points display, 0 when no points)

2. Extend SELECT_ANSWER action to include timeRemaining:
   ```typescript
   | { type: 'SELECT_ANSWER'; optionId: string; isCorrect: boolean; timeRemaining: number }
   ```

**In use-quiz-reducer.ts:**

1. Import scoring functions from `@/services/scoring`

2. Update initialState:
   - `consecutiveCorrect: 0` (was combo: 1)
   - `lastPointsEarned: 0`

3. Update SELECT_ANSWER case:
   - Get comboTier using getComboTier(state.consecutiveCorrect)
   - Calculate points with calculateAnswerPoints if correct, else 0
   - Increment consecutiveCorrect if correct, reset to 0 if incorrect
   - Set lastPointsEarned to points.total (or 0)

4. Update TICK_TIMER timeout case:
   - Reset consecutiveCorrect to 0 (was combo: 1)
   - Set lastPointsEarned to 0

5. Update NEXT_QUESTION:
   - Reset lastPointsEarned to 0

**Important:** The combo display in ScoreDisplay expects `combo` prop. Add a derived getter or update QuizState to include both consecutiveCorrect and a derived comboTier. Simplest: keep `combo` in state but derive it from consecutiveCorrect during SELECT_ANSWER.

Actually, simplest approach: keep field named `combo` but use getComboTier to set its value. That way ScoreDisplay continues working.

Final approach for state:
- `consecutiveCorrect: number` - raw count (0, 1, 2, 3...)
- `combo: number` - displayed tier (1, 2, 3)
- `lastPointsEarned: number`

In SELECT_ANSWER:
- If correct: consecutiveCorrect + 1, combo = getComboTier(consecutiveCorrect + 1)
- If incorrect: consecutiveCorrect = 0, combo = 1
  </action>
  <verify>
- `npx tsc --noEmit` passes
- SELECT_ANSWER action now requires timeRemaining parameter
- QuizState has consecutiveCorrect and lastPointsEarned fields
  </verify>
  <done>Types extended and reducer calculates points with speed bonus and combo tiers</done>
</task>

<task type="auto">
  <name>Task 3: Wire scoring to quiz screen and add perfect round handling</name>
  <files>medtriad/app/quiz/index.tsx</files>
  <action>
1. Update handleAnswerSelect to pass timeRemaining:
   ```typescript
   dispatch({
     type: 'SELECT_ANSWER',
     optionId: option.id,
     isCorrect: option.isCorrect,
     timeRemaining: state.timeRemaining,
   });
   ```

2. Import isPerfectRound from scoring service

3. Update auto-advance effect to check for perfect round:
   - If on last question and correctCountRef.current === QUESTION_COUNT:
     - Add isPerfect: 'true' to router params
   - Otherwise isPerfect: 'false'

4. Destructure lastPointsEarned from state (will be used by Plan 02 for floating points)

5. Update max combo tracking to use consecutiveCorrect:
   - Track max consecutiveCorrect, then convert to tier with getComboTier for bestStreak param
   - Or simpler: track maxCombo directly (the tier value)

Current maxComboRef logic tracks combo+1 on correct. With new approach:
- After dispatch, if correct, check if new combo > maxComboRef and update
- combo is now the tier (1, 2, 3), so maxComboRef tracks max tier seen
  </action>
  <verify>
- `npm run ios` launches and quiz works
- Points increase on correct answers
- Fast answers give more points than slow answers
- Combo tier increases after 3, 6 correct in a row
- Timer timeout gives 0 points
  </verify>
  <done>Quiz screen wired to scoring system with speed bonus and combo tiers working</done>
</task>

</tasks>

<verification>
Run the app and verify scoring mechanics:
1. Answer correctly fast -> see ~150 points (100 base + ~50 speed bonus)
2. Answer correctly slow -> see ~100 points (100 base + minimal speed bonus)
3. Get 3 in a row -> see 2x multiplier (combo badge shows x2)
4. Get 6 in a row -> see 3x multiplier
5. Answer incorrectly -> combo resets to 1x
6. Let timer expire -> 0 points earned, combo resets
7. Get 10/10 -> isPerfect param passed to results (Phase 5 will show celebration)
</verification>

<success_criteria>
- All scoring requirements (SCOR-01, SCOR-02, SCOR-03, SCOR-04) implemented
- Timer timeout requirement (TIME-03) working for 0 points
- Points displayed in header reflect new calculations
- Console log shows point breakdown (or verify via state inspection)
</success_criteria>

<output>
After completion, create `.planning/phases/04-game-mechanics/04-01-SUMMARY.md`
</output>
