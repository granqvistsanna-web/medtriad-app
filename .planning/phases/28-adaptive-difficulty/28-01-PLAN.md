---
phase: 28-adaptive-difficulty
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - medtriad/services/adaptive-selection.ts
autonomous: true

must_haves:
  truths:
    - "Triads are classified as easy/medium/hard/new based on performance history"
    - "Categories with below-average accuracy are identified as weak"
    - "Weighted random selection favors weak categories, tricky items, and hard triads"
    - "New triads (fewer than 3 attempts) are classified as 'new' not easy/medium/hard"
  artifacts:
    - path: "medtriad/services/adaptive-selection.ts"
      provides: "All adaptive selection logic"
      exports: ["classifyDifficulty", "getWeakCategories", "calculateTriadWeight", "selectAdaptiveTriads"]
  key_links:
    - from: "medtriad/services/adaptive-selection.ts"
      to: "medtriad/services/triad-performance-storage.ts"
      via: "loadTriadPerformance import"
      pattern: "from.*triad-performance-storage"
    - from: "medtriad/services/adaptive-selection.ts"
      to: "medtriad/services/study-storage.ts"
      via: "loadTrickyQuestions import"
      pattern: "from.*study-storage"
---

<objective>
Create the adaptive selection service with difficulty classification, category weakness detection, and weighted random selection algorithms.

Purpose: Build the core logic that makes quiz mode "smart" - prioritizing weak areas and tricky content while considering user tier.

Output: New `adaptive-selection.ts` service with all selection algorithms ready for quiz integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-adaptive-difficulty/28-RESEARCH.md

# Key dependencies
@medtriad/services/triad-performance-storage.ts
@medtriad/services/study-storage.ts
@medtriad/services/mastery.ts
@medtriad/services/triads.ts
@medtriad/types/triad.ts
@medtriad/types/triad-performance.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adaptive selection service with all algorithms</name>
  <files>medtriad/services/adaptive-selection.ts</files>
  <action>
Create new service file `medtriad/services/adaptive-selection.ts` with the following functions:

**1. classifyDifficulty(performance: TriadPerformance | null): 'easy' | 'medium' | 'hard' | 'new'**
- If performance is null or totalAttempts < 3, return 'new' (ADPT-05)
- Calculate accuracy = correctCount / (correctCount + incorrectCount)
- Easy: accuracy >= 0.85 (85%+)
- Medium: accuracy >= 0.51 (51-84%)
- Hard: accuracy < 0.51 (50% or below)

**2. getWeakCategories(performanceRecord: TriadPerformanceRecord, allTriads: Triad[]): Set<TriadCategory>**
- Group triads by category
- For each category, calculate accuracy from aggregated performance data
- Calculate overall accuracy across all triads
- Return categories with accuracy below overall average
- Handle edge case: if category has no attempts yet, don't include it in weak set

**3. calculateTriadWeight(params): number**
Params: { triad, performance, trickyIds, weakCategories, userTier }
- Base weight: 1.0 (every triad has a chance)
- Weak category multiplier: 2.0x if triad.category is in weakCategories (ADPT-01)
- Tricky multiplier: 3.0x if triad.id is in trickyIds (ADPT-02)
- Difficulty-tier multiplier (ADPT-04):
  - For tier 1-2: no adjustment (beginners get even distribution)
  - For tier 3-4: hard triads get 1.3x
  - For tier 5-6: hard triads get 1.5x, medium triads get 1.2x
- Multipliers stack multiplicatively
- Return final weight (never < 1.0)

**4. weightedRandomSelect<T>(items: T[], weights: number[], count: number): T[]**
- Implements cumulative weight algorithm from research
- Selects `count` unique items without replacement
- After each selection, removes item and recalculates cumulative weights
- Returns array of selected items

**5. selectAdaptiveTriads(count: number, userTier: number): Promise<Triad[]>**
- Load performance data via loadTriadPerformance()
- Load tricky questions via loadTrickyQuestions()
- Get all triads via getAllTriads()
- Calculate weak categories
- For each triad, calculate weight using calculateTriadWeight
- Use weightedRandomSelect to pick `count` triads
- Return selected triads

Export all functions for testing and use in quiz integration.

Follow existing service patterns from triad-performance-storage.ts (async/await, try/catch with console.error, explicit types).
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd medtriad && npx tsc --noEmit
```
  </verify>
  <done>
- classifyDifficulty returns 'new' for < 3 attempts
- classifyDifficulty returns correct difficulty tier based on accuracy thresholds
- getWeakCategories identifies categories below average
- calculateTriadWeight applies all multipliers correctly
- selectAdaptiveTriads returns requested number of triads
- All functions properly typed and exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for difficulty classification</name>
  <files>medtriad/services/__tests__/adaptive-selection.test.ts</files>
  <action>
Create test file `medtriad/services/__tests__/adaptive-selection.test.ts` with tests for:

**classifyDifficulty tests:**
- Returns 'new' when performance is null
- Returns 'new' when totalAttempts < 3
- Returns 'new' when totalAttempts === 2
- Returns 'easy' when accuracy >= 85% (e.g., 9/10)
- Returns 'medium' when accuracy 51-84% (e.g., 6/10)
- Returns 'hard' when accuracy <= 50% (e.g., 4/10)
- Edge case: exactly 85% accuracy returns 'easy'
- Edge case: exactly 51% accuracy returns 'medium'

**calculateTriadWeight tests:**
- Base weight is 1.0 with no factors
- Weak category multiplies by 2.0
- Tricky multiplies by 3.0
- Tier 5+ hard triad multiplies by 1.5
- Multiple factors stack multiplicatively (e.g., weak + tricky = 6.0)
- Tiers 1-2 get no difficulty adjustment

Use Jest testing patterns consistent with existing project tests (if any exist, otherwise use standard Jest describe/it/expect).
  </action>
  <verify>
```bash
cd medtriad && npm test -- --testPathPattern=adaptive-selection
```
Tests pass.
  </verify>
  <done>
- All classifyDifficulty threshold tests pass
- All calculateTriadWeight multiplier tests pass
- Tests cover edge cases (boundary conditions)
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compiles
cd medtriad && npx tsc --noEmit

# Tests pass
cd medtriad && npm test -- --testPathPattern=adaptive-selection

# File exists with expected exports
grep -E "export (function|async function)" medtriad/services/adaptive-selection.ts
```
</verification>

<success_criteria>
- New adaptive-selection.ts service exists with 5 exported functions
- classifyDifficulty correctly handles minimum 3 attempts requirement (ADPT-05)
- Difficulty thresholds match spec (85%/51% boundaries) (ADPT-03)
- Weight calculation applies all multipliers for weak categories, tricky, and tier (ADPT-01, ADPT-02, ADPT-04)
- Unit tests verify classification logic
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/28-adaptive-difficulty/28-01-SUMMARY.md`
</output>
