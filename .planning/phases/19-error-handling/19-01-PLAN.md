---
phase: 19-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - medtriad/services/validation.ts
  - medtriad/components/ErrorBoundary.tsx
  - medtriad/app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "Render errors show fallback UI instead of crashing"
    - "clamp() returns value within bounds for any input"
    - "clampTier() returns 1-6 for any input"
    - "clampProgress() returns 0-1 for any input"
    - "safeInt() returns fallback for non-numeric input"
  artifacts:
    - path: "medtriad/services/validation.ts"
      provides: "clamp, clampTier, clampProgress, safeInt utilities"
      exports: ["clamp", "clampTier", "clampProgress", "safeInt"]
    - path: "medtriad/components/ErrorBoundary.tsx"
      provides: "React error boundary with fallback UI"
      exports: ["ErrorBoundary"]
    - path: "medtriad/app/_layout.tsx"
      provides: "Root layout wrapped with ErrorBoundary"
      contains: "<ErrorBoundary>"
  key_links:
    - from: "medtriad/app/_layout.tsx"
      to: "medtriad/components/ErrorBoundary.tsx"
      via: "import and JSX wrapper"
      pattern: "import.*ErrorBoundary.*from"
---

<objective>
Create error boundary and validation utilities foundation

Purpose: Establish defensive programming primitives that prevent crashes from invalid state and catch render errors gracefully
Output: ErrorBoundary component wrapping root layout, validation utilities for clamping values
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-error-handling/19-RESEARCH.md

@medtriad/app/_layout.tsx
@medtriad/constants/theme.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation utilities</name>
  <files>medtriad/services/validation.ts</files>
  <action>
Create new file with defensive value clamping utilities:

```typescript
/**
 * Validation Utilities
 *
 * Defensive value clamping for error-free state handling.
 * All functions handle NaN, Infinity, and invalid inputs safely.
 */

/**
 * Clamp a number to a range, handling NaN and Infinity
 */
export function clamp(value: number, min: number, max: number): number {
  if (!Number.isFinite(value)) return min;
  return Math.max(min, Math.min(max, value));
}

/**
 * Clamp tier number to valid range 1-6
 */
export function clampTier(tier: number): number {
  return clamp(Math.floor(tier), 1, 6);
}

/**
 * Clamp progress to 0-1 range for progress bars
 */
export function clampProgress(progress: number): number {
  return clamp(progress, 0, 1);
}

/**
 * Parse value as integer with fallback for invalid input
 */
export function safeInt(value: unknown, fallback: number): number {
  const parsed = typeof value === 'string' ? parseInt(value, 10) : Number(value);
  return Number.isFinite(parsed) ? Math.floor(parsed) : fallback;
}
```

Ensure all functions handle edge cases:
- NaN returns min/fallback
- Infinity returns min/fallback
- Undefined/null returns fallback for safeInt
  </action>
  <verify>
File exists at medtriad/services/validation.ts with all 4 exports.
TypeScript compiles without errors: `cd medtriad && npx tsc --noEmit`
  </verify>
  <done>validation.ts exports clamp, clampTier, clampProgress, safeInt</done>
</task>

<task type="auto">
  <name>Task 2: Create ErrorBoundary component</name>
  <files>medtriad/components/ErrorBoundary.tsx</files>
  <action>
Create class-based error boundary component:

```typescript
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { Colors, Typography, Spacing, Radius } from '@/constants/theme';

interface Props {
  children: ReactNode;
  onReset?: () => void;
}

interface State {
  hasError: boolean;
}

/**
 * Error Boundary for catching render errors
 *
 * Wraps the app to catch JavaScript errors in child component tree.
 * Shows user-friendly fallback UI with retry option.
 *
 * Note: Does NOT catch errors in:
 * - Event handlers (use try/catch)
 * - Async code (use try/catch)
 * - Server-side rendering
 */
export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error for debugging (could send to error service in production)
    console.error('ErrorBoundary caught error:', error);
    console.error('Component stack:', errorInfo.componentStack);
  }

  handleReset = () => {
    this.setState({ hasError: false });
    this.props.onReset?.();
  };

  render() {
    if (this.state.hasError) {
      const colors = Colors.light;
      return (
        <View style={[styles.container, { backgroundColor: colors.background }]}>
          <Text style={[styles.title, { color: colors.text }]}>
            Something went wrong
          </Text>
          <Text style={[styles.message, { color: colors.textMuted }]}>
            We're sorry, but something unexpected happened.
          </Text>
          <Pressable
            style={[styles.button, { backgroundColor: colors.primary }]}
            onPress={this.handleReset}
          >
            <Text style={[styles.buttonText, { color: '#FFFFFF' }]}>
              Try Again
            </Text>
          </Pressable>
        </View>
      );
    }
    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Spacing.xl,
  },
  title: {
    ...Typography.heading,
    marginBottom: Spacing.sm,
    textAlign: 'center',
  },
  message: {
    ...Typography.body,
    textAlign: 'center',
    marginBottom: Spacing.xl,
  },
  button: {
    paddingHorizontal: Spacing.xl,
    paddingVertical: Spacing.md,
    borderRadius: Radius.lg,
  },
  buttonText: {
    ...Typography.label,
    fontWeight: '600',
  },
});
```

Use project theme tokens (Colors.light, Typography, Spacing, Radius).
Use Pressable instead of Button for consistent styling with app.
  </action>
  <verify>
File exists at medtriad/components/ErrorBoundary.tsx.
TypeScript compiles: `cd medtriad && npx tsc --noEmit`
  </verify>
  <done>ErrorBoundary component with fallback UI and reset functionality</done>
</task>

<task type="auto">
  <name>Task 3: Wrap root layout with ErrorBoundary</name>
  <files>medtriad/app/_layout.tsx</files>
  <action>
Update _layout.tsx to wrap the entire app with ErrorBoundary:

1. Add import at top: `import { ErrorBoundary } from '@/components/ErrorBoundary';`

2. Wrap the return JSX with ErrorBoundary:
```typescript
return (
  <ErrorBoundary>
    <ThemeProvider value={LightTheme}>
      <Stack>
        {/* ... existing screens ... */}
      </Stack>
      <StatusBar style="dark" />
    </ThemeProvider>
  </ErrorBoundary>
);
```

The ErrorBoundary must be the outermost wrapper to catch errors from any child component including ThemeProvider and navigation.
  </action>
  <verify>
App launches successfully: `cd medtriad && npx expo start --ios`
_layout.tsx imports ErrorBoundary and wraps root content.
  </verify>
  <done>Root layout wrapped with ErrorBoundary, render errors show fallback UI</done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds: `cd medtriad && npx tsc --noEmit`
2. App launches without errors
3. ErrorBoundary visible in _layout.tsx wrapping all content
4. validation.ts exports all 4 utility functions
</verification>

<success_criteria>
- validation.ts created with clamp, clampTier, clampProgress, safeInt
- ErrorBoundary.tsx created with fallback UI
- _layout.tsx wraps app with ErrorBoundary
- TypeScript compiles without errors
- App launches successfully
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-handling/19-01-SUMMARY.md`
</output>
